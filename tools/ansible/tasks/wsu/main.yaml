---
- hosts: localhost
  vars:
    project_root: "{{ playbook_dir }}/../../../.."
    kubelet_location: "https://dl.k8s.io/v1.16.2/kubernetes-node-windows-amd64.tar.gz"
    wmcb_exe: "wmcb.exe"

  tasks:
    - name: Gather required files
      block:

        - name: Create directory to store files to be used later
          tempfile:
            state: directory
          register: tmp_dir

        - name: Build WMCB
          make:
            target: build
            chdir: "{{ project_root }}"

        - name: Move WMCB to temporary directory
          command: mv "{{ project_root }}/{{ wmcb_exe }}" "{{ tmp_dir.path }}/{{ wmcb_exe }}"

        - name: Download Windows node kubelet
          get_url:
            url: "{{ kubelet_location }}"
            dest: "{{ tmp_dir.path }}/kube.tar.gz"

        - name: Extract kubelet
          unarchive:
            src: "{{ tmp_dir.path }}/kube.tar.gz"
            dest: "{{ tmp_dir.path }}"

        - name: Grab kubelet from extracted directories
          copy:
            src: "{{ tmp_dir.path }}/kubernetes/node/bin/kubelet.exe"
            dest: "{{ tmp_dir.path }}/kubelet.exe"

        - name: Create temporary cni directory
          file:
            path: "{{ tmp_dir.path }}/cni"
            state: directory

        - name: Get cni plugins
          unarchive:
            src: "https://github.com/containernetworking/plugins/releases/download/v0.8.2/cni-plugins-windows-amd64-v0.8.2.tgz"
            dest: "{{ tmp_dir.path }}/cni"
            remote_src: yes

- hosts: win
  vars:
    tmp_path: "{{ playbook_dir }}/tmp"

  tasks:
    - name: Create temporary directory
      win_tempfile:
        state: directory
      register: win_temp_dir
    - name: Copy required files to Windows host
      win_copy:
        src: "{{ hostvars['localhost']['tmp_dir']['path'] }}/"
        dest: "{{ win_temp_dir.path }}"

    - name: Get ignition file
      win_get_url:
        url: "https://api-int.{{ cluster_address }}:22623/config/worker"
        dest: "{{ win_temp_dir.path }}\\worker.ign"
        validate_certs: no

    - name: Get hybrid overlay exe
      win_get_url:
        url: "https://github.com/openshift/windows-machine-config-operator/releases/download/0.1/hybrid-overlay.exe"
        dest: "{{ win_temp_dir.path }}\\hybrid-overlay.exe"
        follow_redirects: all

    - name: Check hybrid overlay SHA256
      win_shell: "certutil -hashfile {{ win_temp_dir.path }}\\hybrid-overlay.exe sha256"
      register: hybrid_sha256
      failed_when: "hybrid_sha256.stdout_lines[1] != 'fa0ecdc4abd3e3cf6b88541a32eba59e947be08b783be9a39951126182f30f65'"

    - name: Run bootstrapper
      win_shell: "{{ win_temp_dir.path }}\\wmcb.exe initialize-kubelet --ignition-file {{ win_temp_dir.path }}\\worker.ign --kubelet-path {{ win_temp_dir.path }}\\kubelet.exe"
      register: bootstrap_out

    - name: Check if bootstrap was successful
      fail:
        msg: "Bootstrapper error"
      when: '"Bootstrapping completed successfully" not in bootstrap_out.stderr'

    - name: Initial wait for bootstrap CSR
      pause:
        seconds: 60

    - name: Check for bootstrap CSR
      delegate_to: localhost
      shell: "oc get csr | awk '/system:serviceaccount:openshift-machine-config-operator:node-bootstrapper/ && /Pending/ {print $1}'"
      register: bootstrap_csrs
      until: bootstrap_csrs.stdout != ""
      retries: 2
      delay: 60

    - name: Approve pending bootstrap CSRs
      delegate_to: localhost
      shell: "oc adm certificate approve {{ item }}"
      with_items: "{{ bootstrap_csrs.stdout_lines }}"

    - name: Initial wait for node CSR
      pause:
        seconds: 60

    - name: Wait for node CSR
      delegate_to: localhost
      shell: "oc get csr | awk '/system:node:/ && /Pending/ {print $1}'"
      register: node_csrs
      until: node_csrs.stdout != ""
      retries: 2
      delay: 60

    - name: Approve pending node CSRs
      delegate_to: localhost
      shell: "oc adm certificate approve {{ item }}"
      with_items: "{{ node_csrs.stdout_lines }}"

    # Get the bootstrapped windows node name. We're using the IP address of the Windows VM created
    # in the inventory file and if the node has multiple internal IP's or external IP's it may not work well.
    # TODO: Move this to a more deterministic way of identifying the node we just bootstrapped
    - name: Get bootstrapped node name
      delegate_to: localhost
      shell: "oc get node -o wide |awk '/{{ inventory_hostname }}/ {print $1}'"
      register: node_name
      until: node_name.stdout != ""
      retries: 3
      delay: 5

    # Check if worker label is already applied to the Windows nodes bootstrapped via WMCB
    # We should always get a single node that we've bootstrapped recently, if not skip this
    # step
    - name: Check if worker label is already applied to the Windows nodes bootstrapped via WMCB
      delegate_to: localhost
      shell: "oc get node {{ node_name.stdout_lines[0] }} -o yaml | grep -i node-role.kubernetes.io/worker"
      ignore_errors: yes
      register: checklabels
      when: node_name.stdout_lines | length == 1

    # Apply worker label to the Windows nodes bootstrapped via WMCB
    - name: Label the Windows node that was just bootstrapped with worker labels
      delegate_to: localhost
      shell: "oc label node {{ node_name.stdout_lines[0] }} node-role.kubernetes.io/worker="
      when: node_name.stdout_lines | length == 1 and checklabels.rc == 1

    - name: Start the hybrid overlay
      win_shell: "Start-Process -NoNewWindow -FilePath \"{{  win_temp_dir.path }}\\hybrid-overlay.exe\" -ArgumentList \"--node  {{ node_name.stdout }} --k8s-kubeconfig c:\\k\\kubeconfig\""
      async: 60
      poll: 0
      register: async_results

    - name: Wait for the hybrid overlay
      delegate_to: localhost
      shell: "oc get nodes {{ node_name.stdout }} -o=jsonpath='{.metadata.annotations}'"
      register: overlay
      until: '"k8s.ovn.org/hybrid-overlay-distributed-router-gateway-mac" in overlay.stdout'
      retries: 12
      delay: 5

    - name: Get hybrid overlay subnet
      delegate_to: localhost
      shell: oc get nodes "{{ node_name.stdout }}" -o=jsonpath='{.metadata.annotations.k8s\.ovn\.org/hybrid-overlay-hostsubnet}'
      register: hybrid_subnet

    - name: Move the CNI folder to the install directory
      win_copy:
        src: "{{ win_temp_dir.path }}\\cni"
        dest: "C:\\k\\"
        remote_src: yes

    - name: Create cni config
      win_copy:
        content: "{\"cniVersion\":\"0.2.0\",\"name\":\"OpenShiftNetwork\",\"type\":\"win-overlay\",\"capabilities\":{\"dns\":true},\"ipam\":{\"type\":\"host-local\",\"subnet\":\"{{ hybrid_subnet.stdout }}\"},\"policies\":[{\"name\":\"Endpoin
tPolicy\",\"value\":{\"Type\":\"OutBoundNAT\",\"ExceptionList\":[\"10.132.0.0/16\"]}},{\"name\":\"EndpointPolicy\",\"value\":{\"Type\":\"ROUTE\",\"DestinationPrefix\":\"10.132.0.0/16\",\"NeedEncap\":true}}]}"
        dest: "C:\\k\\cni\\cni.conf"

    - name: Configure CNI
      win_shell: "{{ win_temp_dir.path }}\\wmcb.exe configure-cni --cni-dir=\"c:\\k\\cni\" --cni-config=\"c:\\k\\cni\\cni.conf\""
      register: bootstrap_out

    - name: Check if CNI configuration was successful
      fail:
        msg: "CNI Configuration error"
      when: '"CNI configuration completed successfully" not in bootstrap_out.stderr'
